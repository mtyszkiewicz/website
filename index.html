<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>mtyszkiewicz.dev</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body, html {
            height: 100%;
            overflow: hidden;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 50%, #dee2e6 100%);
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, sans-serif;
        }
        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        #noise-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
            opacity: 0.05;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><defs><filter id="noise"><feflood flood-color="white"/><fecomponenttransfer><fefunca type="discrete" tablevalues="0 .5 0 1 0 .8 0 .2 0 .9"/></fecomponenttransfer><fecomposite operator="over" in2="SourceGraphic"/></filter></defs><rect width="100%" height="100%" filter="url(%23noise)"/></svg>') repeat;
            animation: noise 0.2s infinite linear;
        }
        @keyframes noise {
            0%, 100% { transform: translate(0, 0); }
            10% { transform: translate(-1px, -1px); }
            20% { transform: translate(1px, 1px); }
            30% { transform: translate(-1px, 1px); }
            40% { transform: translate(1px, -1px); }
            50% { transform: translate(-1px, -1px); }
            60% { transform: translate(1px, 1px); }
            70% { transform: translate(-1px, 1px); }
            80% { transform: translate(1px, -1px); }
            90% { transform: translate(-1px, -1px); }
        }
        .tesseract-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: min(90vw, 90vh);
            height: min(90vw, 90vh);
            z-index: 10;
        }
        .edge {
            position: absolute;
            height: 1px; /* Thinner lines for sharper appearance */
            transform-origin: 0 50%;
            opacity: 1; /* Full opacity for sharper appearance */
            /* box-shadow: 0 0 3px rgba(0, 0, 0, 0.15); */
        }
        /* Apply device-specific styles */
        @media (max-width: 767px) {
            .edge {
                height: 0.5px; /* Slimmer lines on mobile */
                opacity: 1; /* Full opacity on mobile */
                box-shadow: none; /* Remove shadow for better performance */
            }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="noise-overlay"></div>
    
    <div class="tesseract-container" id="container">
        <!-- Edges will be created by JavaScript -->
    </div>

    <script>
        // Detect mobile for optimizations
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 768;
        
        // Check if device is high-end mobile (like iPhone 15 Pro)
        // This helps us apply appropriate optimizations based on device capability
        const isHighEndMobile = (function() {
            // Check for iPhone models 12 and above (which have A14 Bionic chip or better)
            const isNewIPhone = /iPhone1[2-9]|iPhone2[0-9]/i.test(navigator.userAgent);
            // Check for high-end Android devices (rough estimation based on cores and RAM)
            const isHighEndAndroid = /Android.*Chrome\/[7-9][0-9]|Android.*Chrome\/[1-9][0-9][0-9]/i.test(navigator.userAgent);
            return isNewIPhone || isHighEndAndroid;
        })();
        
        // Speed multiplier for mobile devices - makes animations run 2.5x faster on mobile
        const mobileSpeedMultiplier = isMobile ? 2.5 : 1.0;

        // Helper function to generate random numbers with normal distribution (bell curve)
        function randomNormal(mean, stdDev) {
            // Box-Muller transform
            const u1 = Math.random();
            const u2 = Math.random();
            const z0 = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);
            return z0 * stdDev + mean;
        }

        class RainSystem {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.rainDrops = [];
                this.particles = [];
                this.time = 0;
                this.lastTimestamp = 0;
                this.timeStep = 1000 / 60; // Target 60 FPS time step
                this.resize();
                this.init();
                this.animate(0);
                window.addEventListener('resize', () => this.resize());
            }

            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.width = this.canvas.width;
                this.height = this.canvas.height;
            }

            init() {
                // Adjust count based on device capability
                // High-end mobile devices can handle more raindrops
                const rainCount = isMobile ? (isHighEndMobile ? 100 : 70) : 120;
                // No particles on mobile as requested by user for optimization
                const particleCount = isMobile ? 0 : 25;

                // Create rain drops with bell curve distribution for lengths
                for (let i = 0; i < rainCount; i++) {
                    // Use normal distribution for length (mean = 30, stdDev = 10)
                    // This creates a bell curve distribution centered at 30 with most values between 10-50
                    let length = randomNormal(30, 10);
                    // Clamp length to reasonable values (min 10, max 60)
                    length = Math.max(10, Math.min(60, length));
                    
                    this.rainDrops.push({
                        x: Math.random() * (this.width + 100) - 50,
                        y: Math.random() * this.height - this.height,
                        speed: Math.random() * 3 + 3, // Initial speed
                        acceleration: 0.05 + Math.random() * 0.05, // Increased acceleration for more noticeable effect
                        maxSpeed: 12 + Math.random() * 5, // Maximum speed cap
                        length: length, // Bell curve distributed lengths
                        opacity: Math.random() * 0.6 + 0.4, // Higher base opacity for better visibility
                        angle: Math.random() * 6 - 3, // Reduced angle variation
                        drift: (Math.random() - 0.5) * 0.05 // Much smaller drift
                    });
                }

                // Create floating particles (only for desktop)
                if (!isMobile) {
                    for (let i = 0; i < particleCount; i++) {
                        this.particles.push({
                            x: Math.random() * this.width,
                            y: Math.random() * this.height,
                            vx: (Math.random() - 0.5) * 0.3,
                            vy: (Math.random() - 0.5) * 0.3,
                            size: Math.random() * 2 + 1,
                            opacity: Math.random() * 0.3 + 0.1,
                            life: Math.random() * 1000
                        });
                    }
                }
            }

            updateRain(timeScale = 1) {
                this.rainDrops.forEach(drop => {
                    // Apply acceleration to speed with time scaling
                    drop.speed += drop.acceleration * timeScale;
                    
                    // Cap the speed at the maximum value
                    if (drop.speed > drop.maxSpeed) {
                        drop.speed = drop.maxSpeed;
                    }
                    
                    // Update position with time scaling
                    drop.y += drop.speed * timeScale;
                    drop.x += drop.drift * timeScale;
                    
                    // Much smaller wind effect with time scaling
                    drop.drift += Math.sin(this.time * 0.005 + drop.x * 0.0005) * 0.005 * timeScale;
                    
                    // Reset when off screen
                    if (drop.y > this.height + drop.length) {
                        drop.y = -drop.length - Math.random() * 200;
                        drop.x = Math.random() * (this.width + 100) - 50;
                        
                        // Reset speed to initial lower value
                        drop.speed = Math.random() * 3 + 3;
                        drop.drift = (Math.random() - 0.5) * 0.05; // Reset drift
                        
                        // Generate new length with bell curve distribution
                        let length = randomNormal(30, 10);
                        drop.length = Math.max(10, Math.min(60, length));
                    }
                    
                    // Wrap horizontally if drifted too far (less likely now)
                    if (drop.x > this.width + 50) {
                        drop.x = -50;
                    } else if (drop.x < -50) {
                        drop.x = this.width + 50;
                    }
                });
            }

            updateParticles(timeScale = 1) {
                this.particles.forEach(particle => {
                    // Simpler physics for mobile performance, but with time scaling
                    particle.x += particle.vx * timeScale;
                    particle.y += particle.vy * timeScale;
                    
                    // Reduced calculations for mobile, but with time scaling
                    if (!isMobile) {
                        particle.vy += Math.sin(particle.x * 0.01 + this.time * 0.01) * 0.005 * timeScale;
                        particle.vx += Math.cos(particle.y * 0.01 + this.time * 0.01) * 0.005 * timeScale;
                    }
                    
                    // Damping (adjusted for time scaling)
                    const dampFactor = Math.pow(0.999, timeScale);
                    particle.vx *= dampFactor;
                    particle.vy *= dampFactor;
                    
                    // Boundary wrapping
                    if (particle.x < 0) particle.x = this.width;
                    if (particle.x > this.width) particle.x = 0;
                    if (particle.y < 0) particle.y = this.height;
                    if (particle.y > this.height) particle.y = 0;
                    
                    // Lifecycle with time scaling
                    particle.life += timeScale;
                    if (particle.life > 2000) {
                        particle.life = 0;
                        particle.x = Math.random() * this.width;
                        particle.y = Math.random() * this.height;
                    }
                });
            }

            drawRain() {
                this.rainDrops.forEach(drop => {
                    this.ctx.save();
                    
                    // Calculate end point of rain stripe
                    const endX = drop.x + Math.sin(drop.angle * Math.PI / 180) * drop.length;
                    const endY = drop.y + Math.cos(drop.angle * Math.PI / 180) * drop.length;
                    
                    // Draw rain stripe as a line
                    this.ctx.beginPath();
                    this.ctx.moveTo(drop.x, drop.y);
                    this.ctx.lineTo(endX, endY);
                    
                    // Improved coloring for mobile - higher opacity for sharper look
                    if (isMobile) {
                        // Higher opacity for mobile (0.9 instead of drop.opacity)
                        this.ctx.strokeStyle = `rgba(108, 117, 125, 0.9)`;
                        this.ctx.lineWidth = 0.5; // Slimmer lines for mobile
                    } else {
                        // Create gradient for the rain stripe on desktop
                        const gradient = this.ctx.createLinearGradient(drop.x, drop.y, endX, endY);
                        gradient.addColorStop(0, `rgba(108, 117, 125, ${drop.opacity * 0.1})`);
                        gradient.addColorStop(0.5, `rgba(108, 117, 125, ${drop.opacity})`);
                        gradient.addColorStop(1, `rgba(108, 117, 125, ${drop.opacity * 0.1})`);
                        this.ctx.strokeStyle = gradient;
                        this.ctx.lineWidth = 1.5;
                    }
                    
                    this.ctx.lineCap = 'round';
                    this.ctx.stroke();
                    
                    this.ctx.restore();
                });
            }

            drawParticles() {
                // Skip drawing particles on mobile as requested for optimization
                if (isMobile) return;
                
                this.particles.forEach(particle => {
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    this.ctx.fillStyle = `rgba(108, 117, 125, ${particle.opacity})`;
                    this.ctx.fill();
                });
            }

            animate(timestamp) {
                // Calculate delta time since last frame
                const deltaTime = timestamp - this.lastTimestamp;
                this.lastTimestamp = timestamp;
                
                // Clear canvas
                this.ctx.clearRect(0, 0, this.width, this.height);
                
                // Calculate how many time steps to simulate
                // This ensures consistent animation speed regardless of frame rate
                const steps = Math.max(1, Math.floor(deltaTime / this.timeStep));
                
                // Apply mobile speed multiplier to make animations faster on mobile
                const timeIncrement = (1 / steps) * mobileSpeedMultiplier;
                
                // Update multiple times if needed to maintain consistent speed
                for (let i = 0; i < steps; i++) {
                    // Update rain and particles with normalized time increment
                    this.updateRain(timeIncrement);
                    this.updateParticles(timeIncrement);
                    this.time += timeIncrement;
                }
                
                // Draw everything
                this.drawRain();
                this.drawParticles();
                
                requestAnimationFrame((ts) => this.animate(ts));
            }
        }

        class Tesseract4D {
            constructor(containerId) {
                this.container = document.getElementById(containerId);
                
                // Define the 16 vertices of a tesseract in 4D space
                this.originalVertices = [
                    // Inner cube (w = -1)
                    [-1, -1, -1, -1], // 0
                    [ 1, -1, -1, -1], // 1
                    [ 1,  1, -1, -1], // 2
                    [-1,  1, -1, -1], // 3
                    [-1, -1,  1, -1], // 4
                    [ 1, -1,  1, -1], // 5
                    [ 1,  1,  1, -1], // 6
                    [-1,  1,  1, -1], // 7
                    // Outer cube (w = 1)
                    [-1, -1, -1,  1], // 8
                    [ 1, -1, -1,  1], // 9
                    [ 1,  1, -1,  1], // 10
                    [-1,  1, -1,  1], // 11
                    [-1, -1,  1,  1], // 12
                    [ 1, -1,  1,  1], // 13
                    [ 1,  1,  1,  1], // 14
                    [-1,  1,  1,  1]  // 15
                ];

                // Define the 32 edges of a tesseract
                this.edges = [
                    // Inner cube edges (w = -1)
                    [0, 1], [1, 2], [2, 3], [3, 0], // front face
                    [4, 5], [5, 6], [6, 7], [7, 4], // back face
                    [0, 4], [1, 5], [2, 6], [3, 7], // connecting edges
                    // Outer cube edges (w = 1)
                    [8, 9], [9, 10], [10, 11], [11, 8], // front face
                    [12, 13], [13, 14], [14, 15], [15, 12], // back face
                    [8, 12], [9, 13], [10, 14], [11, 15], // connecting edges
                    // 4D connecting edges (inner to outer)
                    [0, 8], [1, 9], [2, 10], [3, 11],
                    [4, 12], [5, 13], [6, 14], [7, 15]
                ];

                // 4D rotation angles
                this.rotXY = Math.random() * Math.PI * 2;
                this.rotXZ = Math.random() * Math.PI * 2;
                this.rotXW = Math.random() * Math.PI * 2;
                this.rotYZ = Math.random() * Math.PI * 2;
                this.rotYW = Math.random() * Math.PI * 2;
                this.rotZW = Math.random() * Math.PI * 2;

                // Use the same base rotation speeds for all devices
                // We'll use time-based animation to ensure consistent speed
                this.speedXY = 0.003 + Math.random() * 0.004;
                this.speedXZ = 0.003 + Math.random() * 0.004;
                this.speedXW = 0.003 + Math.random() * 0.004;
                this.speedYZ = 0.003 + Math.random() * 0.004;
                this.speedYW = 0.003 + Math.random() * 0.004;
                this.speedZW = 0.003 + Math.random() * 0.004;
                
                // Time tracking for consistent animation speed
                this.lastTimestamp = 0;
                this.timeStep = 1000 / 60; // Target 60 FPS

                this.animate(0);
            }

            // 4D rotation methods (unchanged)
            rotateXY(point, angle) {
                const [x, y, z, w] = point;
                const cos = Math.cos(angle);
                const sin = Math.sin(angle);
                return [x * cos - y * sin, x * sin + y * cos, z, w];
            }

            rotateXZ(point, angle) {
                const [x, y, z, w] = point;
                const cos = Math.cos(angle);
                const sin = Math.sin(angle);
                return [x * cos - z * sin, y, x * sin + z * cos, w];
            }

            rotateXW(point, angle) {
                const [x, y, z, w] = point;
                const cos = Math.cos(angle);
                const sin = Math.sin(angle);
                return [x * cos - w * sin, y, z, x * sin + w * cos];
            }

            rotateYZ(point, angle) {
                const [x, y, z, w] = point;
                const cos = Math.cos(angle);
                const sin = Math.sin(angle);
                return [x, y * cos - z * sin, y * sin + z * cos, w];
            }

            rotateYW(point, angle) {
                const [x, y, z, w] = point;
                const cos = Math.cos(angle);
                const sin = Math.sin(angle);
                return [x, y * cos - w * sin, z, y * sin + w * cos];
            }

            rotateZW(point, angle) {
                const [x, y, z, w] = point;
                const cos = Math.cos(angle);
                const sin = Math.sin(angle);
                return [x, y, z * cos - w * sin, z * sin + w * cos];
            }

            rotate4D(point) {
                let rotated = point;
                rotated = this.rotateXY(rotated, this.rotXY);
                rotated = this.rotateXZ(rotated, this.rotXZ);
                rotated = this.rotateXW(rotated, this.rotXW);
                rotated = this.rotateYZ(rotated, this.rotYZ);
                rotated = this.rotateYW(rotated, this.rotYW);
                rotated = this.rotateZW(rotated, this.rotZW);
                return rotated;
            }

            projectTo2D(point4D) {
                const containerSize = Math.min(this.container.offsetWidth, this.container.offsetHeight);
                const scale = containerSize * 0.2;
                const centerX = this.container.offsetWidth / 2;
                const centerY = this.container.offsetHeight / 2;

                const distance4D = 4;
                const w = point4D[3];
                const perspective4D = distance4D / (distance4D - w);
                const x3D = point4D[0] * perspective4D;
                const y3D = point4D[1] * perspective4D;

                return [centerX + x3D * scale, centerY - y3D * scale];
            }

            render() {
                // Clear container
                this.container.innerHTML = '';

                // Apply 4D rotation to all vertices
                const rotated4D = this.originalVertices.map(vertex => this.rotate4D(vertex));

                // Project to 2D
                const projected2D = rotated4D.map(vertex => this.projectTo2D(vertex));

                // Create edges
                this.edges.forEach((edge, index) => {
                    const [startIdx, endIdx] = edge;
                    const start = projected2D[startIdx];
                    const end = projected2D[endIdx];
                    
                    const deltaX = end[0] - start[0];
                    const deltaY = end[1] - start[1];
                    const length = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    const angle = Math.atan2(deltaY, deltaX) * 180 / Math.PI;

                    const edgeElement = document.createElement('div');
                    edgeElement.className = 'edge';
                    edgeElement.style.left = start[0] + 'px';
                    edgeElement.style.top = start[1] + 'px';
                    edgeElement.style.width = length + 'px';
                    edgeElement.style.transform = `rotate(${angle}deg)`;

                    // Use consistent colors across all devices
                    if (index < 12) {
                        edgeElement.style.backgroundColor = '#DB2B39'; // Darker shade
                    } else if (index < 24) {
                        edgeElement.style.backgroundColor = '#29335c'; // Darker shade
                    } else {
                        edgeElement.style.backgroundColor = '#8d99ae'; // Darker shade
                    }

                    this.container.appendChild(edgeElement);
                });
            }

            animate(timestamp) {
                // Calculate delta time since last frame
                const deltaTime = timestamp - this.lastTimestamp;
                this.lastTimestamp = timestamp;
                
                // Calculate how many time steps to simulate
                // This ensures consistent animation speed regardless of frame rate
                const steps = Math.max(1, Math.floor(deltaTime / this.timeStep));
                
                // Apply mobile speed multiplier to make animations faster on mobile
                const timeScale = (1 / steps) * mobileSpeedMultiplier;
                
                // Update rotation angles with time scaling for consistent speed
                for (let i = 0; i < steps; i++) {
                    this.rotXY += this.speedXY * timeScale;
                    this.rotXZ += this.speedXZ * timeScale;
                    this.rotXW += this.speedXW * timeScale;
                    this.rotYZ += this.speedYZ * timeScale;
                    this.rotYW += this.speedYW * timeScale;
                    this.rotZW += this.speedZW * timeScale;
                }

                // Use requestAnimationFrame with a callback that checks if the component is still mounted
                // This prevents unnecessary renders if the page is navigated away from
                if (this.container && document.body.contains(this.container)) {
                    this.render();
                    requestAnimationFrame((ts) => this.animate(ts));
                }
            }
        }

        // Initialize when page loads
        let rainSystem;
        let tesseract;
        
        window.addEventListener('load', () => {
            rainSystem = new RainSystem();
            tesseract = new Tesseract4D('container');
        });
    </script>
</body>
</html>
